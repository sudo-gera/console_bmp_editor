### Array

*C-style массивы эффективней в использовании чем массивы в динамической памяти, из-за известного на этапе компиляции
фиксированного размера и более эффективного расположения в памяти (стековая/автоматическая память). Однако едва ли
C-массивы можно назвать удобными в использовании - они приводятся к указателям, для них не работает оператор присваивания и т.д.

#### std::array (C++11)

Начиная с C++11 в стандартной библиотеке (заголовочный файл <array>) [появился](https://en.cppreference.com/w/cpp/container/array) шаблонный класс std::array<T, N>,
параметризованный типом хранимых элементов T и размером N. Этот класс содержит единственное поле типа "массив T из
N элементов" и предоставляет методы для удобного доступа к информации (размер, элементы и т.д), а также изменения
элементов массива. Класс std::array в полной мере обеспечивает функционал обычных массивов, не теряя при этом
эффективности. Поэтому в современном C++ принято использовать именно std::array вместо C-style массивов.


#### Детали реализации

Вам необходимо реализовать шаблонный класс Array - упрощенный аналог std::array. Ваш класс должен быть
параметризован типом хранимых элементов, а также размером массива. Как было сказано ранее, этот класс должна иметь ровно
одно поле - C-style массив требуемого типа и размера.

c++
int arr[4]{1, 2, 3};  // Массив {1, 2, 3, 0}
Array<int, 4> wrapped_arr{1, 2, 3};  // ООП-обёртка над массивом {1, 2, 3, 0}

Для корректного прохождения тестов ваш класс должен реализовывать следующие методы (подумайте, какие методы должны быть
константными, какие - неконстантными, а какие должны иметь обе версии):
* Оператор [] для доступа к элементу массива по индексу;
* Методы Front() и Back() для доступа к первому и последнему элементу соответственно;
* Метод Data(), возвращающий указатель на начало массива;
* Методы Size() и Empty();
* Метод Swap(Array<T, N>& other) для обмена содержимым между двумя массивами.
* Также предстоит подумать над константной версией этих методов