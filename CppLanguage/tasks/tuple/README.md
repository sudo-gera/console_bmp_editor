### Tuple

В этой задаче вам предстоит реализовать аналог класса [std::tuple](https://en.cppreference.com/w/cpp/utility/tuple). Данный класс представляет из себя контейнер для хранения объектов произвольных `trivially destructible` типов, и является обобщением класса `std::pair` для переменного числа элементов)

*Пример:*
```c++
    Tuple<> empty_tup; // Пустой кортеж.
    Tuple<char, int, double> tup('0', 0, 0.0); // Кортеж, с элементами разных типов.
```

C++ поддерживает множество парадигм программирования, и для реализации своего кортежа придётся воспользоваться приёмом из функционального программирования - `хвостовой рекурсией` и применить её к специализации шаблонов.

Для реализации пригодится следующая идея:
```c++
    template <typename... T>
    class Tuple; // Объявили шаблонный класс.

    template <typename Head, typename... Tail>
    class Tuple<Head, Tail...> : Tuple<Tail...>  {
        ...
    }; // Кортеж - пара из нового элемента и всего основного.

    class Tuple<> {
        ...
    }; // Специализация шаблона для пустого кортежа, выход из шаблонной рекурсии.
```
Для класса `std::tuple` в стандартной библиотеке есть следующие утилитарные классы:
- [tuple_size](https://en.cppreference.com/w/cpp/utility/tuple/tuple_size) - шаблонный класс, который хранит размер кортежа.
- [tuple_cat](https://en.cppreference.com/w/cpp/utility/tuple/tuple_cat) - шаблонная функция, которая возвращает результат конкатенации произвольного числа кортежей.
- [get](https://en.cppreference.com/w/cpp/utility/tuple/get) - шаблонная функция для доступа к элементу по индексу или типу.
- [make_tuple](https://en.cppreference.com/w/cpp/utility/tuple/make_tuple) - шаблонная функция, которая принимает произвольное количество аргументов, и возвращает кортеж (выводит типы автоматически).

Вам предстоит адаптировать эти функции под свою реализацию кортежа.

**ВНИМАНИЕ: НУЖНО ИМЕННО АДАПТИРОВАТЬ ИМЕЮЩИЕСЯ ФУНКЦИИ СТАНДАРТНОЙ БИБЛИОТЕКИ**
```c++
    template <typename... Args>
    struct std::tuple_size<Tuple<Args...>> ... {...};
```

Также требуется поддержать `structure-binding initialisation`:
```c++
    Tuple<char, int, double> tup('0', 0, 0.0);
    auto [a, b, c] = tup;
```



#### Детали реализации 
- Правило `пяти`
- Поддержать `structure-binding initialisation`
- Адаптировать функции стандартной библиотеки
