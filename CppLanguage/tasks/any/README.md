
### Any

В этой задаче вам предстоит реализовать аналог класса [std::any](http://en.cppreference.com/w/cpp/experimental/any) из стандарта
C++17. Данный класс позволяет инкапсулировать в себе значение любого типа (такими темпами к какому-нибудь c++30 язык превратится в питон)
*Пример:*
```c++
std::any a = 5;
a = std::string("aba");
std::any b = std::string("hello, world");
std::any c = std::vector<int>{1, 2, 3};
```



#### Детали реализации 
* `Reset()` - обнуляет объект, делая его пустым; 
* `Swap(std::any&)` - обменивает содержимое;
* `HasValue()` - `true`, если объект не пуст, `false` иначе;
* Внешняя шаблонная функция `MakeAny<T>(args...)` - принимает аргументы конструктора, с которым
нужно создать объект типа `T` и возвращает `Any` с этим объектом.
* реализуйте внешнюю шаблонную функцию
`template <class T> T AnyCast(const Any& value)`, которая возвращает значение, в случае, если объект хранит экземпляр какого-то типа и бросает `std::bad_any_cast` в противном случае вам пригодится `dynamic_cast`.
Подробнее [в справочнике](https://en.cppreference.com/w/cpp/utility/any).


### Примечания

* Использование `std::any` и `void *` запрещено.
* Напоминаем, что правильно реализовывать оператор присваивания через конструктор копирования и `Swap`.
* В решении вам понадобится техника [type erasure](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure).
