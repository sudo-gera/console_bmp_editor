
Введение. Отличия С++ от С
==========================
## Перегрузка функций.
### Мотивация:
Вспомним функцию взятия модуля числа в старом-добром ```C```
```c++
int abs(int);                // Looks good.
long labs( long);            // ??
long long llabs( long long); // What the ..?
float fabs(float)            // Omg...
```
Как мы видим, для каждого нового типа у нас есть своя функция с уникальным именем... Пользователю при вызове очень не хотелось бы думать, какой префикс перед ```abs()``` ему нужно подставить. Тут на помощь приходит фича ```C++``` - перегрузка функций (на самом деле, здоровые люди применяют для такого шаблоны, но о них мы узнаем позже).

### Function overloading in action:
*Функции называются перегруженными, если они объявлены в одной области видимости и имеют одно и то же имя.*
**Важно:**
- перегруженные функции не могут отличаться только типом возвращаемого значения
- Перегруженные функции не могут отличаться только ```CV```-квалификаторами ```(const, volatile)```

Более общими словами - у перегруженных функций должны быть разные сигнатуры (На данном этапе в сигнатуру для нас будут входить *имя функции* и *типы её параметров* - пункт 3.20 [черновика стандарта](https://isocpp.org/files/papers/N4860.pdf) ```С++20```).

Перегруженные функции в ```C++```
```c++
int abs(int);                // Looks good.
long abs( long);             // Looks good.
long long abs( long long);   // Looks good.
float abs(float)             // Looks good.
```

## Cсылки.
### Мотивация:
Вспомним работу со структурами в ```C```
```c++
void Push(Stack* st, int data);

// In main function:
Stack st;
// ...
Push (&st, 1);
```
Для избегания копирования объект нужно передавать по указателю. Каждый раз брать его адрес, заменять оператор "точка" ```.``` на оператор "стрелочка" ```->``` (который в языке С есть, нсли вдруг кто-то не знал). Жуть как неудобно...

В языке ```C++``` появилась удобная альтернатива - **ссылки**:
```c++
int i = 0;
int& ref = i; // Reference definition.
```
**Базовые правила:**
- Ссылка - это псевдоним объекта, к которому она привязана. Изменяем ссылку, изменяем и сам объект.
- Ссылка объявляется приписыванием амперсанда ```&``` перед именем переменной.
- Ccылки должны быть инициализированы при объявлении.
- Нельзя объявлять массивы ссылок.
- Нельзя объявлять ссылку на ссылку (```&&``` - это не ссылка на ссылку, это ```rvalue-reference```, с которыми мы познакомимся позже)
```c++
int& arr[10]; // CE - ref array
int& ref;     // CE - must bind ref to variable in initialization.
```

```c++
int i = 0;
int& ref = i;
int& ref_ref = ref; // Compiles. ref_ref is a reference to i!!! because ref is the same as i.
```
Перепишем сишный код:
```c++
void Push(Stack& st, int data);

// In main function:
Stack st;
// ...
Push (st, 1); // Much better.
```

Здесь важно поговорить о ссылках, указателях и модификаторах const и ```r-value``` объектах:
```c++
int i = 0;
const int c_i = 0;

int& ref1 = i;                    // Ok.
int& ref2 = c_i;                  // CE - an attempt to bind non-const ref to const obj.
int& ref3 = 1;                    // CE - an attemptto bind l-value ref to r-value object.

const int& c_ref1 = i;            // Ok.
const int& c_ref2 = c_i;          // Ok.
const int& c_ref3 = 1             // Also ok!

int* ptr1 = &i                    // Ok.
int* ptr2 = &c_i                  // CE - an attempt to set address of const obj to non-const ptr.
int* ptr3 = &1                    // CE - an attempt to set address of literal to ptr.

const int* ptr_to_c1 = &i         // Ok.
const int* ptr_to_c2 = &c_i       // Ok.
const int* ptr_to_c3 = &1         // CE - an attempt to set address of literal to ptr.

int* const cptr = &i; // Just for example - you can change value by adress stored in cptr, but connot change this address.
int other_i = 0;
*cptr = 1;       // Ok.
cptr = &other_i; // CE.
```
Пояснение того, что написвно выше:
- можно безболезненно навешивать ```const```
- нельзя привязывать ```const``` объекты к ```non-const```  указателям или ссылкам. Логика проста - объкт синтаксически помеченный как ```const``` семантически не меняется. Привязывая его к неконстантному чему-то, вы явно даёте возможность его менять, значит скорее всего вы делаете что-то неправильное и ловите CE.
-  не надо путать указатель на константу (на то, что не меняется) и константный указатель (адрес хранимый в котором не меняется) детали в примере.

## Классы и структуры.
### Мотивация:
Реализация длинной арифметики на ```C```

```c++
struct BigInt {
    int* arr;
};

void Add (struct BigInt*, struct BigInt*);

// Or:

typedef struct BigInt {
    int* arr;
} BigInt;

void Add (BigInt*, BigInt*);
```

Неудобно... Каждый раз писать ```struct``` перед именем структуры или добавлять ```typedef``` для создания алиаса. Для операций над структурой нужно передавать указатель на неё в функцию и работать с синтаксисом указателя. Снова жуть...
Встречайте новый синтаксис в ```C++```:
```c++
struct BigInt {
    int* arr
    void Add(const BigInt&);
}
// main func.

BigInt first;
BigInt second;
// init ...
first.add(second);
```
Ну вот же! Совсем другое дело!
Для нас как для пользователей языка появились классы (увидим позже) и упрощённый синтаксис для структур.
### Теперь более формально.
```C++``` поддерживает *объектно-ориентированное программирование (ООП)*. 
Вместе с ООП к нам приехали три его основных принципа:
- Полиморфизм - свойство программного кода изменять свое поведение в зависимости от ситуации, возникающей при выполнении программы. Мы с этим встречались на примере перегрузки функций, когда в зависимости от переданных аргументов функция с одинаковым именем вела себя по-разному.  [Альтернативное объяснение от ребят из НТР](https://vk.com/audio-2001231279_68231279)
- Наследование - фича, позволяющая делать человекочитаемые интерфейсы и избавляться от дублирования кода. Познакомимся с ней позже.
- Инкапсуляция - "сокрытие" деталей реализации от пользователя. Для него наружу торчит только интерфейс, с которым он работает, а детали реализации скрыты от него.
- [Кто-то добавляет сюда абстракцию. Чаще слышумнение, что это можно запихнуть в ту же инкапсуляцию]

### Поговорим подробнее про инкапсуляцию:
В ```C++``` существуют три модификатора доступа:
- private - элементы, доступные только внутри класса.
- protected - элементы, доступные только классу и его наследникам.
- public - элементы, доступные всем.

Под словом *элементы* понимаем  поля, методы, вложенные классы или структуры, алиасы типов

### Поговорим подробнее про методы:
В ```C++``` Есть функции "привязанные" к классу - методы. Если мы говорим о нестатических функциях (а мы говорим о них), то они привязаны не к классу, а к конкретному его *экземпляру*.
Так как метод привязан к экземпляру класса, то он имеет доступ ко всем его полям и методам. Это происходит с помощью неявного захвата указателя на экземпляр класса, от которого этот метод был вызван. Этот указатель имеет имя ```this```.
Кроме того, с точки зрения архитектуры,  теперь мы не просто зовём функцию с какими-то аргументами, а дополнительно с ними тащим указатель на себя, поэтому указатель на метод весит не 8, а 16 байт







